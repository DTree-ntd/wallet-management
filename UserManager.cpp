#include "UserManager.h"
#include <fstream>
#include <sstream>
#include <iostream>
#include <ctime>
#include <cstdlib>
#include <sys/stat.h>
#include <regex>

UserManager::UserManager(const std::string& usersPath)
    : dataFile(usersPath) {
    // Create data directory if it doesn't exist
    std::string dataDir = usersPath.substr(0, usersPath.find_last_of("/\\"));
    struct stat info;
    if (stat(dataDir.c_str(), &info) != 0) {
        #ifdef _WIN32
        system(("mkdir \"" + dataDir + "\"").c_str());
        #else
        system(("mkdir -p \"" + dataDir + "\"").c_str());
        #endif
    }
    
    // Create users.txt file if it doesn't exist
    std::ifstream checkFile(dataFile);
    if (!checkFile.good()) {
        std::ofstream createFile(dataFile);
        if (!createFile.is_open()) {
            std::cout << "Loi: Khong the tao file users.txt!\n";
        }
        createFile.close();
    }
    checkFile.close();

    // Load users data from file
    loadUsers();
}

void UserManager::loadUsers() {
    std::ifstream file(dataFile);
    if (!file.is_open()) {
        std::cout << "Loi: Khong the mo file de doc!\n";
        return;
    }

    std::string line;
    while (std::getline(file, line)) {
        std::stringstream ss(line);
        std::string username, password, fullName, email, phoneNumber, isAdminStr, isAutoGenStr, walletIdsStr;
        
        std::getline(ss, username, '|');
        std::getline(ss, password, '|');
        std::getline(ss, fullName, '|');
        std::getline(ss, email, '|');
        std::getline(ss, phoneNumber, '|');
        std::getline(ss, isAdminStr, '|');
        std::getline(ss, isAutoGenStr, '|');
        std::getline(ss, walletIdsStr);

        bool isAdmin = (isAdminStr == "true");
        bool isAutoGen = (isAutoGenStr == "true");

        User user(username, password, fullName, email, phoneNumber, isAdmin, isAutoGen);
        
        // Parse wallet IDs
        if (!walletIdsStr.empty()) {
            std::stringstream walletSS(walletIdsStr);
            std::string walletId;
            while (std::getline(walletSS, walletId, ',')) {
                user.addWalletId(walletId);
            }
        }

        users[username] = user;
    }
    file.close();
}

bool UserManager::isUsernameExists(const std::string& username) {
    return users.find(username) != users.end();
}

bool UserManager::saveUsers() {
    std::ofstream file(dataFile);
    if (!file.is_open()) {
        std::cout << "Loi: Khong the mo file de ghi!\n";
        return false;
    }

    for (const auto& pair : users) {
        const User& user = pair.second;
        file << user.getUsername() << "|"
             << user.getPassword() << "|"
             << user.getFullName() << "|"
             << user.getEmail() << "|"
             << user.getPhoneNumber() << "|"
             << (user.getIsAdmin() ? "true" : "false") << "|"
             << (user.getIsPasswordAutoGenerate() ? "true" : "false") << "|";
        
        // Save wallet IDs list
        const auto& walletIds = user.getWalletIds();
        for (size_t i = 0; i < walletIds.size(); ++i) {
            file << walletIds[i];
            if (i < walletIds.size() - 1) {
                file << ",";
            }
        }
        file << "\n";
    }
    file.close();
    return true;
}

bool UserManager::isValidEmail(const std::string& email) {
    // Pattern for email: example@domain.com
    const std::regex pattern("^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$");
    return std::regex_match(email, pattern);
}

bool UserManager::isValidPhoneNumber(const std::string& phoneNumber) {
    // Pattern for phone number: 10 digits
    const std::regex pattern("^[0-9]{10}$");
    return std::regex_match(phoneNumber, pattern);
}

RegisterResult UserManager::registerUser(const std::string& username, const std::string& password, 
                                      const std::string& fullName, const std::string& email, 
                                      const std::string& phoneNumber, bool isPasswordAutoGenerated) {
    // Check username
    if (username.empty()) {
        return RegisterResult::INVALID_USERNAME;
    }
    if (isUsernameExists(username)) {
        return RegisterResult::USERNAME_EXISTS;
    }

    // Check password (if not auto-generated)
    if (!isPasswordAutoGenerated && password.empty()) {
        return RegisterResult::INVALID_PASSWORD;
    }

    // Validate email using regex
    if (!isValidEmail(email)) {
        return RegisterResult::INVALID_EMAIL;
    }

    // Validate phone number using regex
    if (!isValidPhoneNumber(phoneNumber)) {
        return RegisterResult::INVALID_PHONE;
    }

    // Create new user
    User newUser(username, password, fullName, email, phoneNumber, false, isPasswordAutoGenerated);
    users[username] = newUser;

    // Save to file
    if (!saveUsers()) {
        users.erase(username); // Remove user from map if file save fails
        return RegisterResult::FILE_ERROR;
    }

    return RegisterResult::SUCCESS;
}

bool UserManager::login(const std::string& username, const std::string& password) {
    std::ifstream file(dataFile);
    std::string line;
    while (std::getline(file, line)) {
        std::stringstream ss(line);
        std::string storedUsername, storedPassword;
        std::getline(ss, storedUsername, '|');
        std::getline(ss, storedPassword, '|');

        if (storedUsername == username && storedPassword == password) {
            return true;
        }
    }
    return false;
}

std::string UserManager::generateRandomPassword() {
    const std::string chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    std::string password;
    std::srand(std::time(nullptr));
    for (int i = 0; i < 8; i++) {
        password += chars[std::rand() % chars.length()];
    }
    return password;
}

void UserManager::sendLoginInfoToUser(const std::string& email, const std::string& username, 
                                    const std::string& password) {
    // TODO: Implement email sending
    std::cout << "Gui thong tin dang nhap den " << email << std::endl;
    std::cout << "Ten dang nhap: " << username << std::endl;
    std::cout << "Mat khau: " << password << std::endl;
}

std::string UserManager::setupOTP(const std::string& username) {
    std::string secretKey = otpManager.generateSecretKey();
    if (secretKey.empty()) {
        return "";
    }
    
    if (!otpManager.saveSecretKey(username, secretKey)) {
        return "";
    }
    
    return otpManager.generateQRCodeURI(username);
}

bool UserManager::verifyOTP(const std::string& username, const std::string& otp) {
    std::string secretKey = otpManager.loadSecretKey(username);
    if (secretKey.empty()) {
        return false;
    }
    
    return otpManager.verifyOTP(otp);
}

bool UserManager::isPasswordAutoGenerated(const std::string& username) {
    auto it = users.find(username);
    if (it != users.end()) {
        return it->second.getIsPasswordAutoGenerate();
    }
    return false;
}

bool UserManager::changePassword(const std::string& username, const std::string& oldPassword, 
                               const std::string& newPassword) {
    auto it = users.find(username);
    if (it != users.end() && it->second.getPassword() == oldPassword) {
        it->second.setPassword(newPassword);
        it->second.setIsPasswordAutoGenerate(false); // Mark password as not auto-generated
        if (!saveUsers()) {
            return false;
        }
        return true;
    }
    return false;
} 